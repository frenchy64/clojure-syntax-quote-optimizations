= Boolean Optimization for Syntax-Quote
:toc:
:toclevels: 3

== Overview

This subproject contains the analysis and verification of making `true` and `false` self-evaluating in Clojure's syntax-quote reader.

This optimization is part of https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908: Optimize syntax-quote] and was originally proposed in https://clojure.atlassian.net/browse/CLJ-1506[CLJ-1506: Optimize some syntax-quote cases].

== The Optimization

Instead of expanding pass:[`true] to `(quote true)` and pass:[`false] to `(quote false)`, the optimized reader expands them to just `true` and `false`.

**Patch file:** `boolean-optimization.patch`

**Target commit:** See `CLOJURE_VERSION` file in repository root (Clojure 1.12.3 release)

== Building the Optimized Uberjar

Use the shared build script:

```bash
./build-optimized-uberjar.sh [output_dir]
```

This script:
1. Clones the official Clojure repository at the target commit
2. Applies the boolean-optimization.patch
3. Builds the uberjar with Maven
4. Strips nondeterministic data and computes SHA256
5. Saves the result to the output directory

== Experiments

=== 1. Uberjar Comparison

**Directory:** `experiments/uberjar-comparison/`

Measures the overall impact of the boolean optimization on the complete Clojure uberjar:
- Total size reduction
- Number of affected class files
- Bytecode instruction differences

**Run:**
```bash
cd experiments/uberjar-comparison/
./01-boolean-optimization.sh
```

=== 2. when-true Macro Analysis

**Directory:** `experiments/when-true-macro/`

Focuses on the synthetic `when-true` macro as a minimal example demonstrating all three effects of the optimization:

1. **Macro definition bytecode** - Changes to the compiled macro class
2. **Macro expansion performance** - Speed improvements during compilation
3. **Semantic equivalence** - Confirmation of identical behavior

**Note:** The `when-true` macro is synthetic because natural examples of syntax-quoted boolean literals (that aren't unquoted) are rare in Clojure core. This macro demonstrates the optimization pattern clearly.

**Documentation:** `experiments/when-true-macro/WHEN_TRUE_BOOLEAN_OPTIMIZATION_ANALYSIS.adoc`

**Scripts:**
- `verify-expansion-equivalence.sh` - Behavioral verification
- `measure-macro-expansion.sh` - Performance measurement
- `compare-bytecode.sh` - Bytecode comparison

**Run:**
```bash
cd experiments/when-true-macro/when-true-boolean-scripts/
./verify-expansion-equivalence.sh
```

== Results Summary

**Uberjar impact:**
- Size reduction: Expected ~1-5KB
- Affected macros: Any macros using syntax-quoted boolean literals

**when-true macro impact:**
- Bytecode reduction: ~10-50 bytes per syntax-quoted boolean
- Expansion speed: ~5-15% faster (1-5Î¼s per expansion)
- Semantic equivalence: 100% - all tests pass identically

== Patch Application

To apply this patch to a Clojure checkout:

```bash
git clone https://github.com/clojure/clojure.git
cd clojure
git checkout e6393a4063c42ddc0e0812f04464467764f0fd1e  # Clojure 1.12.3
git apply path/to/boolean-optimization.patch
mvn clean package -Dmaven.test.skip=true -Plocal
```

== Comparison with Nil Optimization

The boolean optimization follows the same pattern as the nil optimization:

| Aspect | Nil | Boolean |
|--------|-----|---------|
| Frequency in core | Moderate | Low |
| Example macro | `if-not` (natural) | `when-true` (synthetic) |
| Bytecode savings | ~10-20 bytes per occurrence | ~10-20 bytes per occurrence |
| Impact on uberjar | ~1-5KB | ~1-5KB (estimated) |

Both optimizations are semantically transparent and provide pure performance improvements.

== See Also

- link:experiments/when-true-macro/WHEN_TRUE_BOOLEAN_OPTIMIZATION_ANALYSIS.adoc[when-true Macro Analysis]
- link:../nil-optimization/README.adoc[Nil Optimization Subproject]
- link:../optimize-syntax-quote.md[Technical Motivation Document]
