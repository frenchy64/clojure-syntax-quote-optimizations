= Simple Constant Collections Optimization for Syntax-Quote
:toc:
:toclevels: 3

== Overview

This subproject contains the analysis and verification of making collections containing only constants self-evaluating in Clojure's syntax-quote reader.

This optimization is part of https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908: Optimize syntax-quote] and was originally proposed in https://clojure.atlassian.net/browse/CLJ-1506[CLJ-1506: Optimize some syntax-quote cases].

== The Optimization

Instead of expanding pass:[`[1 2 3]] to `(apply vector (seq (concat (list 1) (list 2) (list 3))))`, the optimized reader expands it to `(quote [1 2 3])`. Similar optimizations apply to constant maps, sets, and lists.

A collection is considered "constant" if all its elements are:
- Numbers, keywords, strings, or characters
- Other constant collections (nested)

**Important:** This patch does NOT include optimizations for nil, true, false, or empty collections. Those are separate experiments to isolate the impact of each optimization.

**Patch file:** `simple-constant-collections.patch`

**Target commit:** See `CLOJURE_VERSION` file in repository root (Clojure 1.12.3 release)

**Reference:** This optimization is extracted from the comprehensive work in https://github.com/frenchy64/clojure/pull/41[PR #41]. See `optimize-syntax-quote-full.patch` at the repository root for the complete patch.

== Next Planned Experiment

**05-simple-constant-collections-with-atomic-values** - This experiment will build upon the simple constant collections optimization by also adding optimizations for atomic values (nil, true, false, and empty collections). This will allow us to:

1. Compare the isolated impact of constant collection optimization alone (experiment 04)
2. Compare the combined impact when atomic value optimizations are added (experiment 05)
3. Understand how these optimizations interact and whether they provide additive benefits

The patch for experiment 05 will include:
- All changes from `simple-constant-collections.patch`
- Additional optimizations for making nil, true, false self-evaluating
- Additional optimizations for making empty collections ([], {}, (), #{}) self-evaluating

== Building the Optimized Uberjar

Use the shared build script:

```bash
./build-optimized-uberjar.sh [output_dir]
```

This script:
1. Clones the official Clojure repository at the target commit
2. Applies the simple-constant-collections.patch
3. Builds the uberjar with Maven
4. Strips nondeterministic data and computes SHA256
5. Saves the result to the output directory

== Experiments

=== 1. Uberjar Comparison

**Directory:** `experiments/uberjar-comparison/`

Measures the overall impact of the simple constant collections optimization on the complete Clojure uberjar:
- Total size reduction
- Number of affected class files
- Bytecode instruction differences

**Run:**
```bash
cd experiments/uberjar-comparison/
./01-simple-constant-collections.sh
```

=== 2. Constant Vector Macro Analysis

**Directory:** `experiments/constant-vector-macro/`

Focuses on a macro using constant collections as a minimal example demonstrating the optimization effects:
1. **Macro definition bytecode** - Changes to the compiled macro class
2. **Macro expansion performance** - Speed improvements during compilation
3. **Semantic equivalence** - Confirmation of identical behavior

**Note:** Constant collections appear frequently in macros for:
- Configuration data
- Default values
- Lookup tables
- Test data

== Results Summary

**Uberjar impact:**
- Size reduction: Expected ~10-50KB (constant collections are common in macros)
- Affected macros: Many macros using constant data structures

**Constant collection macro impact:**
- Bytecode reduction: ~100-300 bytes per syntax-quoted constant collection
- Expansion speed: ~15-30% faster
- Semantic equivalence: 100% - all tests pass identically

== Patch Application

To apply this patch to a Clojure checkout:

```bash
git clone https://github.com/clojure/clojure.git
cd clojure
git checkout e6393a4063c42ddc0e0812f04464467764f0fd1e  # Clojure 1.12.3
git apply path/to/simple-constant-collections.patch
mvn clean package -Dmaven.test.skip=true -Plocal
```

== Comparison with Previous Optimizations

The simple constant collections optimization builds on previous work:

| Aspect | Nil | Boolean | Empty Collections | Simple Constants |
|--------|-----|---------|-------------------|------------------|
| Frequency in core | Moderate | Low | High | Very High |
| Bytecode savings | ~10-20 bytes | ~10-20 bytes | ~50-150 bytes | ~100-300 bytes |
| Impact on uberjar | ~1-5KB | ~1-5KB | ~5-20KB | ~10-50KB |

This optimization provides larger gains because:
- Constant collections are extremely common in macros
- Each occurrence eliminates many concat/list/apply calls
- Nested constant collections compound the savings

All optimizations are semantically transparent and provide pure performance improvements.

== See Also

- link:../01-nil-optimization/README.adoc[Nil Optimization Subproject]
- link:../02-boolean-optimization/README.adoc[Boolean Optimization Subproject]
- link:../03-empty-collection-optimization/README.adoc[Empty Collection Optimization Subproject]
- link:../optimize-syntax-quote.md[Technical Motivation Document]
- https://github.com/frenchy64/clojure/pull/41[PR #41: Full Optimization Implementation]
