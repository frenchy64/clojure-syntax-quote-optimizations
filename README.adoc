= Syntax-Quote Optimization Project
:toc:
:toclevels: 3

== Overview

This project contains experimental analysis and verification of piecemeal optimizations to Clojure's syntax-quote (backtick) reader. The goal is to measure and document the impact of individual optimizations before proposing them for inclusion in Clojure.

== Background and Motivation

This work is part of a larger effort tracked in https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908: Optimize syntax-quote]. The overarching ticket proposed comprehensive optimizations to the syntax-quote reader, but the Clojure maintainers determined that the scope was too large. To make more persuasive cases for individual optimizations, we are splitting the work into smaller, focused experiments.

Many of the specific optimizations we're testing were originally proposed in https://clojure.atlassian.net/browse/CLJ-1506[CLJ-1506: Optimize some syntax-quote cases], which suggests making simple literals like `nil`, `true`, `false`, empty collections, and other constants self-evaluating in syntax-quote. This ticket may be repurposed for our initial optimizations.

=== Why Optimize Syntax-Quote?

Syntax-quote is heavily used in Clojure macros. Every time a macro expands, it must execute the syntax-quote code, and the resulting expansion must be compiled. Inefficiencies compound:

* A single developer might trigger thousands of macro expansions per day during development
* Each syntax-quote expansion creates unnecessary allocations and computations
* The expanded code must be compiled, which is slower for complex expressions
* AOT-compiled code is larger when syntax-quote returns verbose expansions

For example, in Clojure 1.12:
```clojure
`[] => (apply vector (seq (concat)))
```

But with optimization:
```clojure
`[] => []
```

Both evaluate to the same value, but the optimized version is:
* Faster to compute at read time
* Faster to compile
* Smaller in the resulting bytecode
* Utilizes cached empty collection constants

== Project Structure

```
clojure-syntax-quote-optimizations/
├── README.adoc                    # This file
├── optimize-syntax-quote.md       # Technical motivation document
├── shared/                        # Shared utilities and scripts
│   ├── build-optimized-uberjar.sh # Generic build script for optimizations
│   └── compare-uberjar.sh         # Generic uberjar comparison script
├── nil-optimization/              # Subproject: nil optimization
│   ├── nil-optimization.patch     # Git patch for the optimization
│   ├── build-optimized-uberjar.sh # Wrapper for shared build script
│   └── experiments/               # Experiments for this optimization
│       ├── uberjar-comparison/    # Overall JAR size impact
│       └── if-not-macro/          # Specific macro analysis
├── boolean-optimization/          # Subproject: boolean optimization
│   ├── boolean-optimization.patch # Git patch for the optimization
│   ├── build-optimized-uberjar.sh # Wrapper for shared build script
│   └── experiments/               # Experiments for this optimization
│       ├── uberjar-comparison/    # Overall JAR size impact
│       └── when-true-macro/       # Synthetic macro analysis
├── empty-collection-optimization/ # Subproject: empty collection optimization
│   ├── empty-collection-optimization.patch # Git patch for the optimization
│   ├── build-optimized-uberjar.sh # Wrapper for shared build script
│   └── experiments/               # Experiments for this optimization
│       ├── uberjar-comparison/    # Overall JAR size impact
│       └── empty-vector-macro/    # Example macro analysis
└── (future optimizations...)
```

== Methodology

Each optimization follows a consistent workflow:

1. **Isolate the change**: Create a minimal git patch that applies cleanly to a specific Clojure release commit
2. **Build optimized JARs**: Use reproducible scripts to build both baseline and optimized versions
3. **Measure impact**: Run experiments at different levels (whole JAR, specific macros, etc.)
4. **Document results**: Provide analysis documents and verification scripts
5. **Verify checksums**: All artifacts are verified with SHA256 checksums for reproducibility

== Optimization Pipeline

The planned sequence of optimizations, from simplest to most complex (based on CLJ-1506 and CLJ-2908):

1. ✓ **Nil optimization** - Make `nil` self-evaluating (completed)
2. ✓ **Boolean literals** - Make `true` and `false` self-evaluating (completed)
3. **Empty collection literals** - Make `[]`, `{}`, `()`, `#{}` self-evaluating
4. **Simple constant collections** - Optimize collections containing only constants
5. **Constant collection lifting** - More sophisticated constant folding
6. **Mixed constant/unquote collections** - Optimize partially constant collections
7. **Splicing optimizations** - Improve unquote-splicing handling
8. **Complex collection patterns** - Advanced optimization patterns

Each optimization builds understanding for the next, starting with the simplest possible change.

== JIRA Ticket Context

* **https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908]**: Overarching ticket for syntax-quote optimizations
  - Initially too broad in scope
  - Being split into smaller, focused tickets
  - This project provides evidence for the split

* **https://clojure.atlassian.net/browse/CLJ-1506[CLJ-1506]**: Specific optimizations proposed
  - Making simple literals self-evaluating
  - May be repurposed for our initial optimizations
  - Covers nil, booleans, and empty collections

== Contributing

When adding a new optimization:

1. Create a new subdirectory at the top level (e.g., `boolean-optimization/`)
2. Include a git patch file that applies to a specific Clojure commit
3. Create a `build-optimized-uberjar.sh` script for building the optimized version
4. Add experiments in an `experiments/` subdirectory
5. Document your findings in AsciiDoc format

== See Also

- link:nil-optimization/README.adoc[Nil Optimization Subproject]
- link:boolean-optimization/README.adoc[Boolean Optimization Subproject]
- link:empty-collection-optimization/README.adoc[Empty Collection Optimization Subproject]
- link:nil-optimization/experiments/uberjar-comparison/01-nil-optimization.md[Nil Uberjar Comparison]
- link:nil-optimization/experiments/if-not-macro/IF_NOT_NIL_OPTIMIZATION_ANALYSIS.adoc[if-not Macro Analysis]
- link:boolean-optimization/experiments/when-true-macro/WHEN_TRUE_BOOLEAN_OPTIMIZATION_ANALYSIS.adoc[when-true Macro Analysis]
- link:empty-collection-optimization/experiments/empty-vector-macro/EMPTY_COLLECTION_OPTIMIZATION_ANALYSIS.adoc[Empty Collection Optimization Analysis]
- link:optimize-syntax-quote.md[Technical Motivation Document]
