= Syntax-Quote Optimization Project
:toc:
:toclevels: 3

== Overview

This project contains experimental analysis and verification of piecemeal optimizations to Clojure's syntax-quote (backtick) reader. The goal is to measure and document the impact of individual optimizations before proposing them for inclusion in Clojure.

== Background and Motivation

This work is part of a larger effort tracked in https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908: Optimize syntax-quote]. The overarching ticket proposed comprehensive optimizations to the syntax-quote reader, but the Clojure maintainers determined that the scope was too large. To make more persuasive cases for individual optimizations, we are splitting the work into smaller, focused experiments.

Many of the specific optimizations we're testing were originally proposed in https://clojure.atlassian.net/browse/CLJ-1506[CLJ-1506: Optimize some syntax-quote cases], which suggests making simple literals like `nil`, `true`, `false`, empty collections, and other constants self-evaluating in syntax-quote. This ticket may be repurposed for our initial optimizations.

=== Why Optimize Syntax-Quote?

Syntax-quote is heavily used in Clojure macros. Every time a macro expands, it must execute the syntax-quote code, and the resulting expansion must be compiled. Inefficiencies compound:

* A single developer might trigger thousands of macro expansions per day during development
* Each syntax-quote expansion creates unnecessary allocations and computations
* The expanded code must be compiled, which is slower for complex expressions
* AOT-compiled code is larger when syntax-quote returns verbose expansions

For example, in Clojure 1.12:
```clojure
`[] => (apply vector (seq (concat)))
```

But with optimization:
```clojure
`[] => []
```

Both evaluate to the same value, but the optimized version is:
* Faster to compute at read time
* Faster to compile
* Smaller in the resulting bytecode
* Utilizes cached empty collection constants

== Project Structure

```
clojure-syntax-quote-optimizations/
├── README.adoc                    # This file
├── optimize-syntax-quote.md       # Technical motivation document
├── shared/                        # Shared utilities and scripts
│   ├── build-optimized-uberjar.sh # Generic build script for optimizations
│   └── compare-uberjar.sh         # Generic uberjar comparison script
├── 01-nil-optimization/           # Subproject: nil optimization
│   ├── nil-optimization.patch     # Git patch for the optimization
│   ├── build-optimized-uberjar.sh # Wrapper for shared build script
│   └── experiments/               # Experiments for this optimization
│       ├── uberjar-comparison/    # Overall JAR size impact
│       └── if-not-macro/          # Specific macro analysis
├── 02-boolean-optimization/       # Subproject: boolean optimization
│   ├── boolean-optimization.patch # Git patch for the optimization
│   ├── build-optimized-uberjar.sh # Wrapper for shared build script
│   └── experiments/               # Experiments for this optimization
│       ├── uberjar-comparison/    # Overall JAR size impact
│       └── when-true-macro/       # Synthetic macro analysis
├── 03-empty-collection-optimization/ # Subproject: empty collection optimization
│   ├── empty-collection-optimization.patch # Git patch for the optimization
│   ├── build-optimized-uberjar.sh # Wrapper for shared build script
│   └── experiments/               # Experiments for this optimization
│       ├── uberjar-comparison/    # Overall JAR size impact
│       └── empty-vector-macro/    # Example macro analysis
└── (future optimizations...)
```

== Methodology

Each optimization follows a consistent workflow:

1. **Isolate the change**: Create a minimal git patch that applies cleanly to a specific Clojure release commit
2. **Build optimized JARs**: Use reproducible scripts to build both baseline and optimized versions
3. **Measure impact**: Run experiments at different levels (whole JAR, specific macros, etc.)
4. **Document results**: Provide analysis documents and verification scripts
5. **Verify checksums**: All artifacts are verified with SHA256 checksums for reproducibility
6. **Automate testing**: Add all experiments to GitHub Actions CI for automatic testing on every push
7. **Validate locally**: AI agents must set up their own environment and run scripts themselves to verify their work and iterate on them until errors are eliminated and the scripts perform as intended. AI agents may stub `strip-nondeterminism` if they are unable to install it to help set up their environment. **Important**: Always use the same version of Java (Java 8) as the one that was used to build the uberjar we're testing against as a baseline, as different Java versions produce significantly different bytecode

=== Reference Implementation

Each experiment may take inspiration from the comprehensive optimization work in https://github.com/frenchy64/clojure/pull/41[PR #41], which contains the full optimization that we are breaking down into smaller pieces. The complete patch from this PR is checked into this repository as `optimize-syntax-quote-full.patch` for reference purposes. Individual experiments extract and test specific optimizations from this broader work.

== Optimization Pipeline

The planned sequence of optimizations, organized by LispReader.java sections (see link:EXPERIMENT_PLAN.adoc[Experiment Plan] for details):

**Completed:**
1. ✓ **Nil optimization** - Make `nil` self-evaluating
2. ✓ **Boolean literals** - Make `true` and `false` self-evaluating
3. ✓ **Empty collection literals** - Make `[]`, `{}`, `()`, `#{}` self-evaluating

**Maps (IPersistentMap):**
4. **Singleton maps** - Optimize 1-entry maps to use map literals (in progress)
5. **Maps with distinct constant keys** - Use map literals when keys are provably distinct
6. **Maps without splices** - Use `(hash-map ...)` instead of concat/apply

**Sets (IPersistentSet):**
7. **Singleton sets** - Optimize 1-element sets
8. **Sets with distinct constants** - Use set literals when elements are distinct
9. **Sets without splices** - Use `(hash-set ...)` instead of concat/apply

**Lists & Vectors:**
10-15. Various splice and constant propagation optimizations

**Constant Propagation:**
16-17. Helper functions and constant collection quoting

Each optimization is tested independently to measure its specific impact.

== JIRA Ticket Context

* **https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908]**: Overarching ticket for syntax-quote optimizations
  - Initially too broad in scope
  - Being split into smaller, focused tickets
  - This project provides evidence for the split

* **https://clojure.atlassian.net/browse/CLJ-1506[CLJ-1506]**: Specific optimizations proposed
  - Making simple literals self-evaluating
  - May be repurposed for our initial optimizations
  - Covers nil, booleans, and empty collections

== Contributing

When adding a new optimization:

1. Create a new subdirectory at the top level with sequential numbering (e.g., `04-next-optimization/`)
2. Include a git patch file that applies to a specific Clojure commit
3. Create a `build-optimized-uberjar.sh` script for building the optimized version
4. Add experiments in an `experiments/` subdirectory
5. Document your findings in AsciiDoc format
6. Add the optimization to the GitHub Actions workflow matrix in `.github/workflows/optimization-experiments.yml` for automated CI testing
7. Update the main `README.adoc` to link to the new optimization

The goal is to enable asking "go onto the next optimization" and have all infrastructure automatically set up following these established patterns.

== See Also

- link:01-nil-optimization/README.adoc[Nil Optimization Subproject]
- link:02-boolean-optimization/README.adoc[Boolean Optimization Subproject]
- link:03-empty-collection-optimization/README.adoc[Empty Collection Optimization Subproject]
- link:04-singleton-maps/README.adoc[Singleton Maps Optimization Subproject]
- link:EXPERIMENT_PLAN.adoc[Complete Experiment Plan]
- link:04-simple-constant-collections/README.adoc[Simple Constant Collections Optimization Subproject]
- link:01-nil-optimization/experiments/uberjar-comparison/01-nil-optimization.md[Nil Uberjar Comparison]
- link:01-nil-optimization/experiments/if-not-macro/IF_NOT_NIL_OPTIMIZATION_ANALYSIS.adoc[if-not Macro Analysis]
- link:02-boolean-optimization/experiments/when-true-macro/WHEN_TRUE_BOOLEAN_OPTIMIZATION_ANALYSIS.adoc[when-true Macro Analysis]
- link:03-empty-collection-optimization/experiments/empty-vector-macro/EMPTY_COLLECTION_OPTIMIZATION_ANALYSIS.adoc[Empty Collection Optimization Analysis]
- link:04-simple-constant-collections/experiments/uberjar-comparison/01-simple-constant-collections.md[Simple Constant Collections Uberjar Comparison]
- link:optimize-syntax-quote.md[Technical Motivation Document]
- https://github.com/frenchy64/clojure/pull/41[PR #41: Full Optimization Implementation]
