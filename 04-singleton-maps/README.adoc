= Singleton Maps Optimization for Syntax-Quote
:toc:
:toclevels: 3

== Overview

This subproject contains the analysis and verification of optimizing syntax-quoted singleton maps (maps with exactly one key-value pair) to use map literals instead of verbose construction code.

This optimization is part of https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908: Optimize syntax-quote] and was originally proposed in https://clojure.atlassian.net/browse/CLJ-1506[CLJ-1506: Optimize some syntax-quote cases].

== The Optimization

Instead of expanding `` `{:a ~x} `` to `(apply hash-map (seq (concat (list :a) (list x))))`, the optimized reader expands it to `{:a x}`.

**Why this is safe:** Singleton maps trivially satisfy Clojure's distinct-keys requirement. Map literals must have distinct keys at both compile-time and runtime, but with only one entry, there's no possibility of key collision.

**Constraint:** This optimization only applies when there are no top-level splices (`~@`) in the map.

**Patch file:** `singleton-maps.patch`

**Target commit:** See `CLOJURE_VERSION` file in repository root (Clojure 1.12.3 release)

**Reference:** This optimization is extracted from the comprehensive work in https://github.com/frenchy64/clojure/pull/41[PR #41]. See `optimize-syntax-quote-full.patch` at the repository root for the complete patch.

== Code Changes

The patch modifies the `IPersistentMap` case in `syntaxQuote()` method of `LispReader.java`:

```java
ISeq seq = keyvals.seq();
// Optimize singleton maps: `{:a ~x} => {:a x}
if(seq != null && seq.count() == 2 && !hasSplice(seq))
    ret = PersistentArrayMap.createAsIfByAssoc(RT.toArray(sqExpandFlat(seq)));
else
    ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq))));
```

Helper functions added:
- `hasSplice(ISeq seq)` - Returns true if seq contains `~@`
- `sqExpandFlat(ISeq seq)` - Flattens seq treating `~@` as `~` for list* calls

== Building the Optimized Uberjar

Use the shared build script:

```bash
./build-optimized-uberjar.sh [output_dir]
```

This script:
1. Clones the official Clojure repository at the target commit
2. Applies the singleton-maps.patch
3. Builds the uberjar with Maven
4. Strips nondeterministic data and computes SHA256
5. Saves the result to the output directory

== Experiments

=== 1. Uberjar Comparison

**Directory:** `experiments/uberjar-comparison/`

Measures the overall impact of the singleton maps optimization on the complete Clojure uberjar:
- Total size reduction
- Number of affected class files
- Bytecode instruction differences

**Run:**
```bash
cd experiments/uberjar-comparison/
./01-singleton-maps.sh
```

== Hypothesis

Singleton maps are common in Clojure code, particularly in:
- Let-destructuring: `` `(let [{:keys [~x]} ~expr] ...) ``
- Keyword arguments: `` `(fn [& {:keys [~opt]}] ...) ``
- Single-entry configuration maps

We hypothesize that:
1. Singleton maps occur frequently enough to provide measurable size reduction
2. Using map literals instead of apply/concat reduces bytecode size by ~50-100 bytes per occurrence
3. Runtime performance improves due to fewer function calls

== Results Summary

Results will be documented after running the experiment.

== Comparison with Previous Optimizations

| Aspect | Nil | Boolean | Empty Collections | Singleton Maps |
|--------|-----|---------|-------------------|----------------|
| Frequency | Moderate | Low | High | Moderate-High |
| Bytecode savings | ~10-20 bytes | ~10-20 bytes | ~50-150 bytes | ~50-100 bytes |
| Scope | Atomic value | Atomic value | Empty collections | 1-entry maps |

== See Also

- link:../01-nil-optimization/README.adoc[Nil Optimization Subproject]
- link:../02-boolean-optimization/README.adoc[Boolean Optimization Subproject]
- link:../03-empty-collection-optimization/README.adoc[Empty Collection Optimization Subproject]
- link:../EXPERIMENT_PLAN.adoc[Complete Experiment Plan]
- link:../optimize-syntax-quote.md[Technical Motivation Document]
- https://github.com/frenchy64/clojure/pull/41[PR #41: Full Optimization Implementation]
