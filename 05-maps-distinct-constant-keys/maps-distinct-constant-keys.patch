From 97dcdb24b0bc758e989b0a06bc542ea82159bb59 Mon Sep 17 00:00:00 2001
From: GitHub Copilot <copilot@github.com>
Date: Wed, 8 Oct 2025 22:45:26 +0000
Subject: [PATCH] Optimize syntax-quote for maps with distinct constant keys

Optimize syntax-quoted maps where all keys are distinct constants and
all values are constant values (keywords, numbers, strings, booleans,
characters, nil) to use map literals instead of (apply hash-map ...).

For example: `{:a 1 :b 2} => {:a 1 :b 2}
instead of (apply hash-map (seq (concat ...)))
---
 src/jvm/clojure/lang/LispReader.java | 75 ++++++++++++++++++++++++++++
 1 file changed, 75 insertions(+)

diff --git a/src/jvm/clojure/lang/LispReader.java b/src/jvm/clojure/lang/LispReader.java
index 8d7079cf..95596223 100644
--- a/src/jvm/clojure/lang/LispReader.java
+++ b/src/jvm/clojure/lang/LispReader.java
@@ -1093,8 +1093,67 @@ public static class SyntaxQuoteReader extends AFn{
 			else if(form instanceof IPersistentMap)
 				{
 				IPersistentVector keyvals = flattenMap(form);
+				// Optimize maps with distinct constant keys to use map literals
+				if(keyvals.count() > 0)
+				{
+					boolean hasDistinctConstantKeys = true;
+					IPersistentSet seenKeys = PersistentHashSet.EMPTY;
+
+					// Check if all keys and values are self-evaluating constants
+					// and that no two keys are equivalent
+					for(int i = 0; i < keyvals.count(); i += 2)
+					{
+						Object key = keyvals.nth(i);
+						Object val = keyvals.nth(i + 1);
+						
+						// Test for self-evaluating constants (key)
+						if(!(key instanceof Keyword) &&
+						   !(key == null) &&
+						   !(key instanceof Number) &&
+						   !(key instanceof String) &&
+						   !(key instanceof Boolean) &&
+						   !(key instanceof Character))
+						{
+							hasDistinctConstantKeys = false;
+							break;
+						}
+						
+						// Test for self-evaluating constants (value)
+						if(!(val instanceof Keyword) &&
+						   !(val == null) &&
+						   !(val instanceof Number) &&
+						   !(val instanceof String) &&
+						   !(val instanceof Boolean) &&
+						   !(val instanceof Character))
+						{
+							hasDistinctConstantKeys = false;
+							break;
+						}
+
+						// Check for duplicate keys
+						if(seenKeys.contains(key))
+						{
+							hasDistinctConstantKeys = false;
+							break;
+						}
+						else
+						{
+							seenKeys = (IPersistentSet) seenKeys.cons(key);
+						}
+					}
+
+					if(hasDistinctConstantKeys)
+					{
+						// All keys are distinct constants, expand to map literal
+						ret = PersistentArrayMap.create(RT.toArray(sqExpandFlat(keyvals.seq())));
+					}
+					else
 				ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq()))));
 				}
+				else
+					ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq()))));
+
+				}
 			else if(form instanceof IPersistentVector)
 				{
 				ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq()))));
@@ -1147,6 +1206,22 @@ public static class SyntaxQuoteReader extends AFn{
 		return ret.seq();
 	}
 
+	// Helper function for flattening seq for map/set literals
+	// Expands unquotes directly (no wrapping in list)
+	private static ISeq sqExpandFlat(ISeq seq) {
+		PersistentVector ret = PersistentVector.EMPTY;
+		for(; seq != null; seq = seq.next())
+			{
+			Object item = seq.first();
+			if(isUnquote(item) || isUnquoteSplicing(item))
+				ret = ret.cons(RT.second(item));
+			else
+				ret = ret.cons(syntaxQuote(item));
+			}
+		return ret.seq();
+	}
+
+
 	private static IPersistentVector flattenMap(Object form){
 		IPersistentVector keyvals = PersistentVector.EMPTY;
 		for(ISeq s = RT.seq(form); s != null; s = s.next())
-- 
2.51.0

