From 7ff6d5522cc4c1c3520f6bf76c20fb1ebb71cf7d Mon Sep 17 00:00:00 2001
From: GitHub Copilot <copilot@github.com>
Date: Wed, 8 Oct 2025 14:50:29 +0000
Subject: [PATCH] Optimize syntax-quote for vectors without splices

Optimize syntax-quoted vectors without unquote-splicing to use vector
literals instead of (apply vector (seq (concat ...))).

For example: `[1 ~x 3] => [1 x 3]
instead of (apply vector (seq (concat (list 1) (list x) (list 3))))

---
 src/jvm/clojure/lang/LispReader.java | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/src/jvm/clojure/lang/LispReader.java b/src/jvm/clojure/lang/LispReader.java
index 8d7079cf..99e549a5 100644
--- a/src/jvm/clojure/lang/LispReader.java
+++ b/src/jvm/clojure/lang/LispReader.java
@@ -1097,7 +1097,13 @@ public static class SyntaxQuoteReader extends AFn{
 				}
 			else if(form instanceof IPersistentVector)
 				{
-				ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq()))));
++				ISeq seq = ((IPersistentVector) form).seq();
+				// `[~@a ...] => (apply vector (seq (concat ~@a ...)))
+				if(hasSplice(seq))
+					ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq()))));
+				// `[a ...] => [`a ...]
+				else
+					ret = LazilyPersistentVector.create(sqExpandList(seq));
 				}
 			else if(form instanceof IPersistentSet)
 				{
@@ -1132,6 +1138,16 @@ public static class SyntaxQuoteReader extends AFn{
 		return ret;
 	}
 
+	// returns true iff seq contains ~@
+	private static boolean hasSplice(ISeq seq) {
+		for(; seq != null; seq = seq.next())
+			{
+			if(isUnquoteSplicing(seq.first()))
+				return true;
+			}
+		return false;
+	}
+
 	private static ISeq sqExpandList(ISeq seq) {
 		PersistentVector ret = PersistentVector.EMPTY;
 		for(; seq != null; seq = seq.next())
-- 
2.51.0

