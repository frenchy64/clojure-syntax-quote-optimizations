= Sets with Distinct Constants Optimization for Syntax-Quote
:toc:
:toclevels: 3

== Overview

This subproject contains the analysis and verification of optimizing syntax-quoted sets where all elements are compile-time constants and provably distinct. Instead of using `(apply hash-set (seq (concat ...)))`, we can use set literals directly when we can verify at compile-time that all elements are constants and none are duplicated.

This optimization is part of https://clojure.atlassian.net/browse/CLJ-2908[CLJ-2908: Optimize syntax-quote].

== The Optimization

For sets where all elements are atomic constants (keywords, strings, numbers, booleans, nil, etc.) and no two elements are equivalent, we can use set literals:

**Before:**
- `` `#{:a :b :c} `` => `(apply hash-set (seq (concat (list :a) (list :b) (list :c))))`

**After (with distinct constants):**
- `` `#{:a :b :c} `` => `#{:a :b :c}`

**After (with non-constants or duplicates - preserved):**
- `` `#{~x ~y} `` => `(apply hash-set (seq (concat (list x) (list y))))`
- `` `#{:a :a} `` => `(apply hash-set (seq (concat ...)))` (duplicate element)

**Why this is safe:** The patch checks that:
1. All elements are constants (not unquoted expressions)
2. No two elements are equivalent according to `clojure.lang.Util/equiv`

When both conditions are met, we can safely use a set literal, which is more efficient. This is similar to experiment 05 (Maps with Distinct Constant Keys) but applies to ALL elements in the set, not just even-indexed keys.

**Constraint:** This optimization requires all elements to be compile-time constants and distinct.

**Patch file:** `sets-distinct-constants.patch`

**Target commit:** See `CLOJURE_VERSION` file in repository root (Clojure 1.12.3 release)

**Reference:** This optimization follows the same pattern as Maps with Distinct Constant Keys (experiment 05).

== Code Changes

The patch modifies the `IPersistentSet` case in `syntaxQuote()` method of `LispReader.java`:

```java
ISeq seq = ((IPersistentSet) form).seq();
// Check if all elements are distinct constants
boolean hasDistinctConstants = false;
if(seq != null)
    {
    hasDistinctConstants = true;
    PersistentVector elements = PersistentVector.EMPTY;
    // Check each element
    for(ISeq s = seq; s != null; s = s.next())
        {
        Object element = s.first();
        // Element must be a self-evaluating constant (keyword, number, string, boolean, nil, char)
        if(!(element instanceof Keyword) && 
           !(element == null) &&
           !(element instanceof Number) &&
           !(element instanceof String) &&
           !(element instanceof Boolean) &&
           !(element instanceof Character))
            {
            hasDistinctConstants = false;
            break;
            }
        // Check if this element is distinct from previous elements
        for(ISeq e = elements.seq(); e != null; e = e.next())
            {
            if(Util.equiv(e.first(), element))
                {
                hasDistinctConstants = false;
                break;
                }
            }
        if(!hasDistinctConstants)
            break;
        elements = elements.cons(element);
        }
    }
// `#{:a :b :c} => #{:a :b :c} (if all elements are distinct constants)
if(hasDistinctConstants && seq != null)
    {
    // Expand each element through syntax-quote
    PersistentVector expanded = PersistentVector.EMPTY;
    for(ISeq s = seq; s != null; s = s.next())
        {
        Object item = s.first();
        if(isUnquote(item))
            expanded = expanded.cons(RT.second(item));
        else
            expanded = expanded.cons(syntaxQuote(item));
        }
    ret = PersistentHashSet.create(RT.toArray(expanded));
    }
else
    ret = RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq))));
```

This uses only existing functions from the codebase (`isUnquote`, `isUnquoteSplicing`, `Util.equiv`, `syntaxQuote`, `sqExpandList`).

**Key change**: A constant is defined as a self-evaluating form (keywords, numbers, strings, booleans, nil, characters). Symbols, sequences, and non-keyword collections are NOT constants because their evaluation is not known at compile-time.

== Building the Optimized Uberjar

Use the shared build script:

```bash
./build-optimized-uberjar.sh [output_dir]
```

This script:
1. Clones the official Clojure repository at the target commit
2. Applies the sets-distinct-constants.patch
3. Builds the uberjar with Maven
4. Strips nondeterministic data and computes SHA256
5. Saves the result to the output directory

== Experiments

=== 1. Uberjar Comparison

**Directory:** `experiments/uberjar-comparison/`

Measures the overall impact of the sets with distinct constants optimization on the complete Clojure uberjar:
- Total size reduction
- Number of affected class files
- Bytecode instruction differences

**Run:**
```bash
cd experiments/uberjar-comparison/
./01-sets-distinct-constants.sh
```

== Hypothesis

Sets with constant elements appear in various contexts in Clojure code:
- Enumeration values: `` `#{:pending :running :complete} ``
- Configuration options
- Validation sets

We hypothesize that:
1. Using set literals instead of `apply/hash-set/concat` reduces bytecode size
2. Set literals are evaluated more efficiently at runtime
3. This optimization complements the sets without splices optimization

== Results Summary

Results will be documented after running the experiment.

== See Also

- link:../05-maps-distinct-constant-keys/README.adoc[Maps with Distinct Constant Keys Optimization Subproject]
- link:../07-singleton-sets/README.adoc[Singleton Sets Optimization Subproject]
- link:../09-sets-without-splices/README.adoc[Sets Without Splices Optimization Subproject]
- link:../EXPERIMENT_PLAN.adoc[Complete Experiment Plan]
- link:../optimize-syntax-quote.md[Technical Motivation Document]
